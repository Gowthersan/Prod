import bcrypt from 'bcryptjs';
import crypto from 'crypto';
import jwt from 'jsonwebtoken';
import prisma from '../config/db.js';
import { AppError } from '../middlewares/error.middleware.js';
import { JwtPayload, LoginVM, OrganisationDTO, UtilisateurDTO } from '../types/index.js';
import { generateOtp } from '../utils/generateOtp.js';
import { sendPasswordChangedEmail, sendPasswordResetEmail } from '../utils/mail_password_reset.js';
import { sendOTPEmail } from '../utils/mailer.js';

// Stockage temporaire des inscriptions en attente (en production, utilisez Redis)
const pendingRegistrations: {
  [email: string]: {
    registrationData: any;
    otp: string;
    otpExpiry: Date;
    type: 'user' | 'organisation';
  };
} = {};

const getJwtSecret = (): string => {
  const secret = process.env.JWT_SECRET;
  if (!secret) {
    throw new Error("JWT_SECRET n'est pas d√©fini dans les variables d'environnement");
  }
  return secret;
};

/**
 * Convertir les BigInt en string pour la s√©rialisation JSON
 */
function serializeBigInt(obj: any): any {
  if (obj === null || obj === undefined) return obj;

  if (typeof obj === 'bigint') {
    return obj.toString();
  }

  if (Array.isArray(obj)) {
    return obj.map(serializeBigInt);
  }

  if (typeof obj === 'object') {
    const serialized: any = {};
    for (const key in obj) {
      serialized[key] = serializeBigInt(obj[key]);
    }
    return serialized;
  }

  return obj;
}

export class AuthService {
  /**
   * INSCRIPTION - √âtape 1 : Enregistrer un agent FPBG et envoyer l'OTP
   * Cette m√©thode g√©n√®re un code OTP et l'envoie par email √† l'utilisateur
   */
  async registerAgentFpbg(userData: UtilisateurDTO) {
    const { email, nomUtilisateur, motDePasse } = userData;

    // ====================================
    // 1. V√©rifier si l'utilisateur existe d√©j√†
    // ====================================
    const existingUser = await prisma.utilisateur.findFirst({
      where: {
        OR: [{ email }]
      }
    });

    if (existingUser) {
      throw new AppError("Email ou nom d'utilisateur d√©j√† utilis√©.", 409);
    }

    // ====================================
    // 2. Hasher le mot de passe pour la s√©curit√©
    // ====================================
    const hashedPassword = await bcrypt.hash(motDePasse, 12);

    // ====================================
    // 3. G√©n√©rer le code OTP (6 chiffres, valide 5 minutes)
    // ====================================
    const otp = generateOtp();
    const otpExpiry = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes

    // ====================================
    // 4. Stocker temporairement les donn√©es d'inscription
    // ====================================
    pendingRegistrations[email] = {
      registrationData: { ...userData, motDePasse: hashedPassword },
      otp,
      otpExpiry,
      type: 'user'
    };

    // ====================================
    // 5. Envoyer l'OTP par email via Nodemailer
    // ====================================
    console.log(`üìß OTP g√©n√©r√© pour ${email}: ${otp}`);

    try {
      await sendOTPEmail(email, otp, userData.prenom || userData.nomUtilisateur || 'Utilisateur');
      console.log(`‚úÖ Email OTP envoy√© √† ${email}`);
    } catch (error: any) {
      console.error(`‚ùå Erreur envoi email √† ${email}:`, error.message);
      throw new AppError("Impossible d'envoyer l'email de v√©rification", 500);
    }

    return {
      message: 'Un code de v√©rification a √©t√© envoy√© √† votre adresse email.',
      email
    };
  }

  /**
   * INSCRIPTION - √âtape 1 : Enregistrer une organisation et envoyer l'OTP
   * Cette m√©thode g√©n√®re un code OTP et l'envoie par email √† l'organisation
   */
  async registerOrganisation(orgData: OrganisationDTO) {
    const { email, motDePasse, ...otherData } = orgData;

    // ====================================
    // 1. V√©rifier si l'email existe d√©j√† (Utilisateur ou Organisation)
    // ====================================
    const existingUser = await prisma.utilisateur.findUnique({ where: { email } });
    const existingOrg = await prisma.organisation.findFirst({ where: { email } });

    if (existingUser || existingOrg) {
      throw new AppError('Cet email est d√©j√† utilis√©.', 409);
    }

    // ====================================
    // 2. Valider et hasher le mot de passe
    // ====================================
    if (!motDePasse || typeof motDePasse !== 'string' || motDePasse.trim() === '') {
      throw new AppError('Un mot de passe valide est requis.', 400);
    }

    const hashedPassword = await bcrypt.hash(motDePasse, 6); // Supprimez l'op√©rateur !

    // ====================================
    // 3. G√©n√©rer le code OTP (6 chiffres, valide 5 minutes)
    // ====================================
    const otp = generateOtp();
    const otpExpiry = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes

    // ====================================
    // 4. Stocker temporairement les donn√©es d'inscription
    // ====================================
    pendingRegistrations[email] = {
      registrationData: { ...orgData, password: hashedPassword },
      otp,
      otpExpiry,
      type: 'organisation'
    };

    // ====================================
    // 5. Envoyer l'OTP par email via Nodemailer
    // ====================================
    console.log(`üìß OTP g√©n√©r√© pour ${email}: ${otp}`);

    try {
      await sendOTPEmail(email, otp, orgData.nom_organisation || orgData.personneContact || 'Organisation');
      console.log(`‚úÖ Email OTP envoy√© √† ${email}`);
    } catch (error: any) {
      console.error(`‚ùå Erreur envoi email √† ${email}:`, error.message);
      throw new AppError("Impossible d'envoyer l'email de v√©rification", 500);
    }

    return {
      message: 'Un code de v√©rification a √©t√© envoy√© √† votre adresse email.',
      email
    };
  }

  /**
   * INSCRIPTION - √âtape 2 : V√©rifier l'OTP et cr√©er le compte
   * Cette m√©thode v√©rifie le code OTP entr√© par l'utilisateur,
   * cr√©e le compte dans la base de donn√©es, et g√©n√®re un token JWT
   */
  async verifyOtp(email: string, otp: string) {
    // ====================================
    // 1. R√©cup√©rer les donn√©es d'inscription en attente
    // ====================================
    const pending = pendingRegistrations[email];

    if (!pending) {
      throw new AppError('Aucune inscription en attente pour cet email.', 400);
    }

    // ====================================
    // 2. V√©rifier que le code OTP est correct
    // ====================================
    if (pending.otp !== otp) {
      throw new AppError('Code OTP invalide.', 400);
    }

    // ====================================
    // 3. V√©rifier que le code OTP n'est pas expir√© (5 minutes)
    // ====================================
    if (pending.otpExpiry < new Date()) {
      delete pendingRegistrations[email];
      throw new AppError("Code OTP expir√©. Veuillez recommencer l'inscription.", 400);
    }

    const { registrationData, type } = pending;

    try {
      if (type === 'user') {
        // ====================================
        // 4a. UTILISATEUR : Cr√©er le compte utilisateur
        // ====================================

        // üî• √âTAPE PR√âALABLE : V√©rifier si l'utilisateur existe d√©j√†
        let existingUser = await prisma.utilisateur.findUnique({
          where: { email: registrationData.email }
        });

        if (existingUser) {
          console.log('‚ö†Ô∏è [INSCRIPTION USER] Utilisateur existe d√©j√† - Connexion au lieu de cr√©ation:', {
            id: existingUser.id,
            email: existingUser.email
          });

          // Supprimer les donn√©es temporaires
          delete pendingRegistrations[email];

          // G√©n√©rer un nouveau token avec le bon userId
          const token = this.generateToken({
            userId: existingUser.id,
            email: existingUser.email,
            userType: 'user'
          });

          const { hashMotPasse: _, ...userWithoutPassword } = existingUser;

          return {
            message: 'Connexion r√©ussie !',
            token,
            user: userWithoutPassword,
            type: 'user',
            redirectTo: '/soumission',
            exigerSondage: true
          };
        }

        // Si l'utilisateur n'existe pas, le cr√©er normalement
        const user = await prisma.utilisateur.create({
          data: {
            email: registrationData.email,
            hashMotPasse: registrationData.motDePasse,
            prenom: registrationData.prenom ?? null,
            nom: registrationData.nom ?? null,
            telephone: registrationData.telephone ?? null,
            role: 'UTILISATEUR'
          }
        });

        // Supprimer les donn√©es temporaires
        delete pendingRegistrations[email];

        // ====================================
        // 5a. G√©n√©rer le token JWT pour la session
        // ====================================
        const token = this.generateToken({
          userId: user.id,
          email: user.email,
          userType: 'user'
        });

        const { hashMotPasse: _, ...userWithoutPassword } = user;

        // ====================================
        // 6. Retourner les donn√©es avec le chemin de redirection
        // ====================================
        return {
          message: 'Compte v√©rifi√© avec succ√®s !',
          token,
          user: userWithoutPassword,
          type: 'user',
          redirectTo: '/soumission', // üéØ Redirection vers soumission
          exigerSondage: true // üéØ Activer le sondage pour les nouveaux utilisateurs
        };
      } else {
        // ====================================
        // 4b. ORGANISATION : Cr√©er User ‚Üí Organisation ‚Üí TypeOrganisation
        // ====================================

        // üî• √âTAPE PR√âALABLE : V√©rifier si l'utilisateur existe d√©j√†
        let existingUser = await prisma.utilisateur.findUnique({
          where: { email: registrationData.email },
          include: {
            organisation: {
              include: { typeSubvention: true }
            }
          }
        });

        if (existingUser) {
          console.log('‚ö†Ô∏è [INSCRIPTION ORG] Utilisateur existe d√©j√† - Connexion au lieu de cr√©ation:', {
            id: existingUser.id,
            email: existingUser.email
          });

          // Supprimer les donn√©es temporaires
          delete pendingRegistrations[email];

          // G√©n√©rer un nouveau token avec le bon userId
          const token = this.generateToken({
            userId: existingUser.id,
            email: existingUser.email,
            userType: 'organisation'
          });

          const { hashMotPasse: _, ...userWithoutPassword } = existingUser;

          return {
            message: 'Connexion r√©ussie !',
            token,
            user: {
              ...userWithoutPassword,
              organisation: existingUser.organisation ? serializeBigInt(existingUser.organisation) : null
            },
            type: 'organisation',
            redirectTo: '/soumission',
            exigerSondage: true
          };
        }

        // Si l'utilisateur n'existe pas, le cr√©er normalement
        const result = await prisma.$transaction(async (tx) => {
          // √âTAPE 1: Cr√©er l'Utilisateur en premier
          console.log('üìù [INSCRIPTION ORG] Donn√©es re√ßues:', {
            email: registrationData.email,
            prenom: registrationData.prenom,
            nom: registrationData.nom,
            personneContact: registrationData.personneContact,
            telephone: registrationData.telephone,
            telephoneContact: registrationData.telephoneContact
          });

          // üéØ Utiliser directement prenom et nom du formulaire
          // personneContact est g√©n√©r√© automatiquement (prenom + nom) c√¥t√© frontend
          const user = await tx.utilisateur.create({
            data: {
              email: registrationData.email,
              hashMotPasse: registrationData.password,
              prenom: registrationData.prenom ?? null,
              nom: registrationData.nom ?? null,
              telephone: registrationData.telephoneContact ?? registrationData.telephone ?? null,
              role: 'UTILISATEUR'
            }
          });

          console.log('‚úÖ [INSCRIPTION ORG] Utilisateur cr√©√©:', {
            id: user.id,
            email: user.email,
            prenom: user.prenom,
            nom: user.nom,
            telephone: user.telephone,
            nomComplet: `${user.prenom} ${user.nom}`
          });

          // √âTAPE 2: Mapper le type d'organisation vers l'enum TypeOrganisation
          const mapTypeOrganisation = (type: string): any => {
            const mapping: Record<string, string> = {
              'Secteur priv√© (PME, PMI, Startups)': 'PRIVE',
              'ONG et Associations': 'ONG',
              'Coop√©ratives communautaires': 'COOPERATIVE',
              'Communaut√©s organis√©es': 'COMMUNAUTE',
              'Entit√©s gouvernementales': 'SECTEUR_PUBLIC',
              'Organismes de recherche': 'RECHERCHE'
            };
            return mapping[type] || 'AUTRE';
          };

          // √âTAPE 2.5: Trouver le TypeSubvention correspondant
          let idTypeSubvention: number | undefined;
          if (registrationData.typeSubvention) {
            const typeSubventionStr = registrationData.typeSubvention.toLowerCase();
            const code = typeSubventionStr.includes('petite')
              ? 'PETITE'
              : typeSubventionStr.includes('moyenne')
              ? 'MOYENNE'
              : null;

            if (code) {
              const typeSubvention = await tx.typeSubvention.findUnique({
                where: { code }
              });
              idTypeSubvention = typeSubvention?.id;
            }
          }

          // √âTAPE 3: Cr√©er l'Organisation li√©e
          const type = registrationData.type;
          const organisation = await tx.organisation.create({
            data: {
              nom: registrationData.nom_organisation ?? registrationData.type ?? 'Organisation',
              type: mapTypeOrganisation(type),
              email: registrationData.email,
              telephone: registrationData.telephone ?? registrationData.telephoneContact ?? null,
              idTypeSubvention, // üéØ Sauvegarder le type de subvention choisi
              utilisateurs: {
                connect: { id: user.id } // üîó Lier l'utilisateur √† l'organisation
              }
            },
            include: {
              typeSubvention: true // üéØ Inclure le typeSubvention dans la r√©ponse
            }
          });

          // √âTAPE 4: R√©cup√©rer l'utilisateur mis √† jour avec idOrganisation
          const updatedUser = await tx.utilisateur.findUnique({
            where: { id: user.id },
            include: {
              organisation: {
                include: {
                  typeSubvention: true
                }
              }
            }
          });

          return { user: updatedUser!, organisation };
        });

        // Supprimer les donn√©es temporaires
        delete pendingRegistrations[email];

        // ====================================
        // 5b. G√©n√©rer le token JWT avec l'ID du User (pas de l'organisation)
        // ====================================
        const token = this.generateToken({
          userId: result.user.id,
          email: result.user.email,
          userType: 'organisation'
        });

        const { hashMotPasse: _, ...userWithoutPassword } = result.user;

        // ====================================
        // 6. Retourner les donn√©es avec le chemin de redirection
        // ====================================
        return {
          message: 'Compte v√©rifi√© avec succ√®s !',
          token,
          user: {
            ...userWithoutPassword,
            organisation: serializeBigInt(result.organisation) // üéØ S√©rialiser les BigInt
          },
          type: 'organisation',
          redirectTo: '/soumission', // üéØ Redirection vers soumission
          exigerSondage: true // üéØ Activer le sondage pour les nouvelles organisations
        };
      }
    } catch (error: any) {
      delete pendingRegistrations[email];
      throw new AppError('Erreur lors de la cr√©ation du compte: ' + error.message, 500);
    }
  }

  /**
   * CONNEXION - Authentification avec email + mot de passe uniquement
   */
  async login(loginData: LoginVM) {
    const { email, motDePasse } = loginData;

    // Le username est maintenant toujours un EMAIL
    // On cherche d'abord parmi les utilisateurs (par email uniquement)
    const user = await prisma.utilisateur.findUnique({
      where: { email: email },
      include: {
        organisation: {
          include: {
            typeSubvention: true // üéØ Inclure le type de subvention
          }
        }
      }
    });

    if (user) {
      // V√©rifier le mot de passe
      const isPasswordValid = await bcrypt.compare(motDePasse, user.hashMotPasse);

      if (!isPasswordValid) {
        throw new AppError('Email ou mot de passe incorrect.', 401);
      }

      // G√©n√©rer le token JWT avec l'ID de l'utilisateur
      const token = this.generateToken({
        userId: user.id,
        email: user.email,
        userType: user.organisation ? 'organisation' : 'user'
      });

      const { hashMotPasse: _, ...userWithoutSensitiveData } = user;

      // ‚úÖ D√©terminer la redirection en fonction du r√¥le
      let redirectTo = '/dashboard'; // Par d√©faut
      if (user.role === 'ADMINISTRATEUR') {
        redirectTo = '/admin/dashboard';
      }

      console.log('‚úÖ [AUTH SERVICE] Login r√©ussi:', {
        email: user.email,
        role: user.role,
        type: user.organisation ? 'organisation' : 'user',
        redirectTo,
        prenom: user.prenom,
        nom: user.nom,
        organisation: user.organisation
          ? {
              nom: user.organisation.nom,
              typeSubvention: user.organisation.typeSubvention
            }
          : null
      });

      const responseData = {
        message: 'Connexion r√©ussie.',
        token,
        user: serializeBigInt(userWithoutSensitiveData), // üéØ S√©rialiser les BigInt
        type: user.organisation ? 'organisation' : 'user',
        role: user.role, // ‚úÖ Ajouter le r√¥le dans la r√©ponse
        redirectTo // ‚úÖ Ajouter la redirection bas√©e sur le r√¥le
      };

      console.log('üìã [AUTH SERVICE] Donn√©es de r√©ponse compl√®tes:', JSON.stringify(responseData, null, 2));

      return responseData;
    }

    throw new AppError('Email ou mot de passe incorrect.', 401);
  }

  /**
   * V√©rifier si l'utilisateur est authentifi√©
   */
  async isAuthenticated(userId: string) {
    // Chercher l'utilisateur avec son organisation
    const user = await prisma.utilisateur.findUnique({
      where: { id: userId },
      include: {
        organisation: {
          include: {
            typeSubvention: true // üéØ Inclure le type de subvention
          }
        }
      }
    });

    if (user) {
      const { hashMotPasse: _, ...userWithoutPassword } = user;
      return {
        user: serializeBigInt(userWithoutPassword), // üéØ S√©rialiser les BigInt
        type: user.organisation ? 'organisation' : 'user'
      };
    }

    throw new AppError('Utilisateur non trouv√©.', 404);
  }

  /**
   * Rafra√Æchir le token
   */
  async refreshToken(userId: string) {
    const { user, type } = await this.isAuthenticated(userId);

    const token = this.generateToken({
      userId: user.id,
      email: user.email,
      userType: type === 'user' ? (user as any).userType : 'organisation'
    });

    return { token, user, type };
  }

  /**
   * G√©n√©rer un token JWT
   */
  private generateToken(payload: JwtPayload): string {
    return jwt.sign(payload, getJwtSecret(), { expiresIn: '7d' });
  }

  /**
   * RENVOYER OTP : G√©n√©rer et envoyer un nouveau code OTP
   * Cette m√©thode permet de renvoyer un nouveau code OTP si le pr√©c√©dent a expir√©
   * ou n'a pas √©t√© re√ßu par l'utilisateur
   */
  async resendOtp(email: string) {
    // ====================================
    // 1. V√©rifier qu'il existe une inscription en attente
    // ====================================
    const pending = pendingRegistrations[email];

    if (!pending) {
      throw new AppError('Aucune inscription en attente pour cet email.', 400);
    }

    // ====================================
    // 2. G√©n√©rer un nouveau code OTP (6 chiffres, valide 5 minutes)
    // ====================================
    const otp = generateOtp();
    const otpExpiry = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes

    // Mettre √† jour le code OTP dans les donn√©es temporaires
    pending.otp = otp;
    pending.otpExpiry = otpExpiry;

    // ====================================
    // 3. Envoyer le nouveau OTP par email via Nodemailer
    // ====================================
    console.log(`üìß Nouveau OTP g√©n√©r√© pour ${email}: ${otp}`);

    try {
      const userName =
        pending.type === 'user'
          ? pending.registrationData.prenom || pending.registrationData.nomUtilisateur || 'Utilisateur'
          : pending.registrationData.nom || pending.registrationData.personneContact || 'Organisation';

      await sendOTPEmail(email, otp, userName);
      console.log(`‚úÖ Nouvel email OTP envoy√© √† ${email}`);
    } catch (error: any) {
      console.error(`‚ùå Erreur envoi email √† ${email}:`, error.message);
      throw new AppError("Impossible d'envoyer l'email de v√©rification", 500);
    }

    return {
      message: 'Un nouveau code de v√©rification a √©t√© envoy√© √† votre adresse email.',
      email
    };
  }

  /**
   * ‚úÖ MOT DE PASSE OUBLI√â : G√©n√®re un token et envoie l'email
   * @param email - Email de l'utilisateur
   * @param frontendOrigin - URL d'origine du frontend (d√©tect√©e automatiquement depuis les headers)
   */
  async forgotPassword(email: string, frontendOrigin?: string) {
    // ====================================
    // 1. V√©rifier si l'utilisateur existe
    // ====================================
    const user = await prisma.utilisateur.findUnique({
      where: { email }
    });

    if (!user) {
      // ‚ö†Ô∏è Pour la s√©curit√©, on ne r√©v√®le pas si l'email existe ou non
      throw new AppError('Aucun compte trouv√© avec cet email.', 404);
    }

    // ====================================
    // 2. G√©n√©rer un token de r√©initialisation s√©curis√©
    // ====================================
    const resetToken = crypto.randomBytes(32).toString('hex');
    const resetTokenHash = crypto.createHash('sha256').update(resetToken).digest('hex');
    const resetTokenExpiry = new Date(Date.now() + 60 * 60 * 1000); // 1 heure

    // ====================================
    // 3. Sauvegarder le token dans la base de donn√©es
    // ====================================
    await prisma.utilisateur.update({
      where: { id: user.id },
      data: {
        resetToken: resetTokenHash,
        resetTokenExpiry
      }
    });

    // ====================================
    // 4. Construire le lien de r√©initialisation
    // ====================================
    // Utiliser l'origine d√©tect√©e, sinon variable d'environnement, sinon URL par d√©faut
    const frontendUrl =
      frontendOrigin || process.env.FRONTEND_URL || 'https://guichetnumerique.fpbg.ga';
    const resetLink = `${frontendUrl}/reset-password?token=${resetToken}`;

    console.log(`üîó [FORGOT-PASSWORD] URL g√©n√©r√©e: ${resetLink}`);
    console.log(`üìß [FORGOT-PASSWORD] Frontend URL utilis√©e: ${frontendUrl}`);
    console.log(`üåê [FORGOT-PASSWORD] Origin pass√©: ${frontendOrigin || 'non fourni'}`);

    // ====================================
    // 5. Envoyer l'email de r√©initialisation
    // ====================================
    const userName = `${user.prenom || ''} ${user.nom || ''}`.trim() || 'Utilisateur';

    try {
      await sendPasswordResetEmail(email, userName, resetLink);
      console.log(`‚úÖ [FORGOT-PASSWORD] Email envoy√© √† ${email} avec le lien de r√©initialisation`);
    } catch (error: any) {
      console.error(`‚ùå [FORGOT-PASSWORD] Erreur envoi email:`, error.message);
      throw new AppError("Impossible d'envoyer l'email de r√©initialisation", 500);
    }

    return {
      message: 'Un email de r√©initialisation a √©t√© envoy√© √† votre adresse.'
    };
  }

  /**
   * ‚úÖ R√âINITIALISATION DU MOT DE PASSE : V√©rifie le token et change le MDP
   */
  async resetPassword(token: string, newPassword: string) {
    // ====================================
    // 1. Hasher le token pour comparer avec la BDD
    // ====================================
    const resetTokenHash = crypto.createHash('sha256').update(token).digest('hex');

    // ====================================
    // 2. Rechercher l'utilisateur avec ce token valide
    // ====================================
    const user = await prisma.utilisateur.findFirst({
      where: {
        resetToken: resetTokenHash,
        resetTokenExpiry: {
          gt: new Date() // Token non expir√©
        }
      }
    });

    if (!user) {
      throw new AppError('Lien de r√©initialisation invalide ou expir√©.', 400);
    }

    // ====================================
    // 3. Hasher le nouveau mot de passe
    // ====================================
    const hashedPassword = await bcrypt.hash(newPassword, 12);

    // ====================================
    // 4. Mettre √† jour le mot de passe et supprimer le token
    // ====================================
    await prisma.utilisateur.update({
      where: { id: user.id },
      data: {
        hashMotPasse: hashedPassword,
        resetToken: null,
        resetTokenExpiry: null
      }
    });

    // ====================================
    // 5. Envoyer un email de confirmation
    // ====================================
    const userName = `${user.prenom || ''} ${user.nom || ''}`.trim() || 'Utilisateur';

    try {
      await sendPasswordChangedEmail(user.email, userName);
      console.log(`‚úÖ [RESET-PASSWORD] Email de confirmation envoy√© √† ${user.email}`);
    } catch (error: any) {
      console.error(`‚ùå [RESET-PASSWORD] Erreur envoi email de confirmation:`, error.message);
      // On ne fait pas √©chouer la r√©initialisation si l'email ne part pas
    }

    return {
      message: 'Votre mot de passe a √©t√© r√©initialis√© avec succ√®s.'
    };
  }
}
